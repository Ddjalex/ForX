<?php

namespace App\Controllers;

use App\Services\Auth;
use App\Services\Database;
use App\Services\Router;
use App\Services\Session;
use App\Services\AuditLog;
use App\Services\AssetService;

class TradingController
{
    public function markets(): void
    {
        $markets = Database::fetchAll(
            "SELECT m.*, p.price, p.change_24h 
             FROM markets m 
             LEFT JOIN prices p ON m.id = p.market_id 
             WHERE m.status = 'active'
             ORDER BY m.type, m.symbol"
        );

        echo Router::render('trading/markets', [
            'markets' => $markets,
            'csrf_token' => Session::generateCsrfToken(),
        ]);
    }

    public function tradeDefault(): void
    {
        $market = Database::fetch(
            "SELECT m.*, p.price, p.change_24h, p.high_24h, p.low_24h, p.volume_24h
             FROM markets m 
             LEFT JOIN prices p ON m.id = p.market_id 
             WHERE m.status = 'active'
             ORDER BY m.type, m.symbol
             LIMIT 1"
        );

        if (!$market) {
            Router::redirect('/dashboard');
            return;
        }

        $this->renderTrade($market);
    }

    public function trade(string $symbol): void
    {
        $market = Database::fetch(
            "SELECT m.*, p.price, p.change_24h, p.high_24h, p.low_24h, p.volume_24h
             FROM markets m 
             LEFT JOIN prices p ON m.id = p.market_id 
             WHERE m.symbol = ? AND m.status = 'active'",
            [$symbol]
        );

        if (!$market) {
            Router::redirect('/dashboard/trade');
            return;
        }

        $this->renderTrade($market);
    }

    private function renderTrade(array $market): void
    {
        $user = Auth::user();
        $wallet = Database::fetch("SELECT * FROM wallets WHERE user_id = ?", [$user['id']]);

        $assetService = new AssetService();
        $assetTypes = $assetService->getAssetTypes();
        
        $allMarkets = Database::fetchAll(
            "SELECT m.*, m.display_name, m.symbol_tradingview, p.price, at.name as asset_type 
             FROM markets m 
             LEFT JOIN prices p ON m.id = p.market_id 
             LEFT JOIN asset_types at ON m.asset_type_id = at.id
             WHERE m.status = 'active' 
             ORDER BY at.sort_order, m.name"
        );
        
        $marketsByType = [];
        foreach ($allMarkets as $m) {
            $type = $m['asset_type'] ?? $m['type'];
            if (!isset($marketsByType[$type])) {
                $marketsByType[$type] = [];
            }
            $marketsByType[$type][] = $m;
        }

        $openPositions = Database::fetchAll(
            "SELECT p.*, m.symbol FROM positions p JOIN markets m ON p.market_id = m.id WHERE p.user_id = ? AND p.status = 'open' ORDER BY p.created_at DESC",
            [$user['id']]
        );

        $closedPositions = Database::fetchAll(
            "SELECT p.*, m.symbol FROM positions p JOIN markets m ON p.market_id = m.id WHERE p.user_id = ? AND p.status = 'closed' ORDER BY p.closed_at DESC LIMIT 50",
            [$user['id']]
        );

        $pendingOrders = Database::fetchAll(
            "SELECT * FROM orders WHERE user_id = ? AND market_id = ? AND status = 'pending'",
            [$user['id'], $market['id']]
        );

        $priceHistory = Database::fetchAll(
            "SELECT price, created_at FROM prices_history 
             WHERE market_id = ? 
             ORDER BY created_at DESC LIMIT 100",
            [$market['id']]
        );

        echo Router::render('trading/trade', [
            'user' => $user,
            'market' => $market,
            'wallet' => $wallet,
            'allMarkets' => $allMarkets,
            'assetTypes' => $assetTypes,
            'marketsByType' => $marketsByType,
            'openPositions' => $openPositions,
            'closedPositions' => $closedPositions,
            'pendingOrders' => $pendingOrders,
            'priceHistory' => array_reverse($priceHistory),
            'csrf_token' => Session::generateCsrfToken(),
            'error' => Session::getFlash('error'),
            'success' => Session::getFlash('success'),
        ]);
    }

    public function placeOrder(): void
    {
        $isAjax = !empty($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] === 'XMLHttpRequest';
        
        $csrfToken = $_POST['_csrf_token'] ?? '';
        if (!empty($csrfToken) && !Session::validateCsrfToken($csrfToken)) {
            if ($isAjax) {
                Router::json(['error' => 'Invalid request. Please reload and try again.'], 403);
            } else {
                Router::json(['error' => 'Invalid request. Please reload and try again.'], 403);
            }
            return;
        }

        $userId = Auth::id();
        $marketId = filter_input(INPUT_POST, 'market_id', FILTER_VALIDATE_INT);
        $orderType = filter_input(INPUT_POST, 'order_type', FILTER_SANITIZE_SPECIAL_CHARS);
        $side = filter_input(INPUT_POST, 'side', FILTER_SANITIZE_SPECIAL_CHARS);
        $amount = filter_input(INPUT_POST, 'amount', FILTER_VALIDATE_FLOAT);
        $leverage = filter_input(INPUT_POST, 'leverage', FILTER_VALIDATE_FLOAT) ?: 1;
        $price = filter_input(INPUT_POST, 'price', FILTER_VALIDATE_FLOAT);
        $stopLoss = filter_input(INPUT_POST, 'stop_loss', FILTER_VALIDATE_FLOAT);
        $takeProfit = filter_input(INPUT_POST, 'take_profit', FILTER_VALIDATE_FLOAT);
        $duration = filter_input(INPUT_POST, 'duration', FILTER_VALIDATE_INT) ?: 1;

        if (!$marketId || !$orderType || !$side || !$amount) {
            $error = 'Please fill in all required fields.';
            if ($isAjax) {
                Router::json(['error' => $error], 400);
            } else {
                Session::flash('error', $error);
                Router::redirect($_SERVER['HTTP_REFERER'] ?? '/dashboard/trade');
            }
            return;
        }

        $market = Database::fetch("SELECT * FROM markets WHERE id = ? AND status = 'active'", [$marketId]);
        if (!$market) {
            $error = 'Invalid market.';
            if ($isAjax) {
                Router::json(['error' => $error], 400);
            } else {
                Session::flash('error', $error);
                Router::redirect('/dashboard/trade');
            }
            return;
        }

        if ($leverage > $market['max_leverage']) {
            $error = "Maximum leverage for this market is {$market['max_leverage']}x.";
            if ($isAjax) {
                Router::json(['error' => $error], 400);
            } else {
                Session::flash('error', $error);
                Router::redirect($_SERVER['HTTP_REFERER'] ?? '/dashboard/trade');
            }
            return;
        }

        if ($amount < $market['min_trade_size']) {
            $error = "Minimum trade size is {$market['min_trade_size']}.";
            if ($isAjax) {
                Router::json(['error' => $error], 400);
            } else {
                Session::flash('error', $error);
                Router::redirect($_SERVER['HTTP_REFERER'] ?? '/dashboard/trade');
            }
            return;
        }

        $wallet = Database::fetch("SELECT * FROM wallets WHERE user_id = ?", [$userId]);
        
        if (!$wallet) {
            $error = 'Wallet not found. Please contact support.';
            if ($isAjax) {
                Router::json(['error' => $error], 400);
            } else {
                Session::flash('error', $error);
                Router::redirect($_SERVER['HTTP_REFERER'] ?? '/dashboard/trade');
            }
            return;
        }

        $currentPrice = Database::fetch("SELECT price FROM prices WHERE market_id = ?", [$marketId]);
        $entryPrice = $currentPrice['price'] ?? 0;

        if ($orderType === 'limit' && $price) {
            $entryPrice = $price;
        }

        // Strict validation: margin required cannot exceed total wallet balance (not just available)
        $marginRequired = ($amount * $entryPrice) / $leverage;
        $availableBalance = $wallet['balance'] - $wallet['margin_used'];

        // Check 1: Must have enough available balance for margin
        if ($marginRequired > $availableBalance) {
            $error = 'Insufficient balance. Available: $' . number_format($availableBalance, 2) . ' | Required: $' . number_format($marginRequired, 2);
            if ($isAjax) {
                Router::json(['error' => $error], 400);
            } else {
                Session::flash('error', $error);
                Router::redirect($_SERVER['HTTP_REFERER'] ?? '/dashboard/trade');
            }
            return;
        }

        // Check 2: Total balance must be positive (cannot trade with $0 balance)
        if ($wallet['balance'] <= 0) {
            $error = 'Your account balance is zero or negative. Please make a deposit.';
            if ($isAjax) {
                Router::json(['error' => $error], 400);
            } else {
                Session::flash('error', $error);
                Router::redirect($_SERVER['HTTP_REFERER'] ?? '/dashboard/trade');
            }
            return;
        }

        // Check 3: Ensure amount doesn't exceed what's possible with available balance
        if ($amount > ($availableBalance * $leverage)) {
            $error = 'Trade amount too large for available balance with selected leverage. Max amount: $' . number_format(($availableBalance * $leverage), 2);
            if ($isAjax) {
                Router::json(['error' => $error], 400);
            } else {
                Session::flash('error', $error);
                Router::redirect($_SERVER['HTTP_REFERER'] ?? '/dashboard/trade');
            }
            return;
        }

        if ($orderType === 'market') {
            $spread = $market['spread'] ?? 0;
            $executionPrice = $side === 'buy' ? $entryPrice * (1 + $spread) : $entryPrice * (1 - $spread);

            $createdAt = date('Y-m-d H:i:s');
            $expiresAt = date('Y-m-d H:i:s', strtotime("+{$duration} minutes"));

            // Check for duplicate position created in the last 2 seconds
            $twoSecondsAgo = date('Y-m-d H:i:s', time() - 2);
            $recentDuplicate = Database::fetch(
                "SELECT id FROM positions 
                 WHERE user_id = ? AND market_id = ? AND side = ? AND amount = ? AND leverage = ? 
                 AND created_at > ?
                 ORDER BY id DESC LIMIT 1",
                [$userId, $marketId, $side, $amount, $leverage, $twoSecondsAgo]
            );
            
            if ($recentDuplicate) {
                // Skip duplicate insertion
                Session::flash('success', 'Trade executed successfully. Your trade has been placed successfully. You can review the details in your trade history.');
                Router::redirect('/dashboard/trades/history');
                return;
            }

            $positionId = Database::insert('positions', [
                'user_id' => $userId,
                'market_id' => $marketId,
                'side' => $side,
                'amount' => $amount,
                'entry_price' => $executionPrice,
                'leverage' => $leverage,
                'margin_used' => $marginRequired,
                'stop_loss' => $stopLoss ?: null,
                'take_profit' => $takeProfit ?: null,
                'status' => 'open',
                'duration' => $duration,
                'expires_at' => $expiresAt,
                'created_at' => $createdAt,
            ]);

            Database::update('wallets', [
                'margin_used' => $wallet['margin_used'] + $marginRequired,
            ], 'user_id = ?', [$userId]);

            Database::insert('trades', [
                'user_id' => $userId,
                'position_id' => $positionId,
                'market_id' => $marketId,
                'side' => $side,
                'amount' => $amount,
                'price' => $executionPrice,
                'fee' => $amount * $executionPrice * ($market['fee'] ?? 0.001),
                'created_at' => date('Y-m-d H:i:s'),
            ]);

            AuditLog::log('open_position', 'position', $positionId, [
                'market' => $market['symbol'],
                'side' => $side,
                'amount' => $amount,
                'price' => $executionPrice,
                'leverage' => $leverage,
            ]);

            Session::flash('success', 'Trade executed successfully. Your trade has been placed successfully. You can review the details in your trade history.');
            Router::redirect('/dashboard/trades/history');
            return;
        } else {
            Database::insert('orders', [
                'user_id' => $userId,
                'market_id' => $marketId,
                'type' => $orderType,
                'side' => $side,
                'amount' => $amount,
                'price' => $price,
                'leverage' => $leverage,
                'stop_loss' => $stopLoss ?: null,
                'take_profit' => $takeProfit ?: null,
                'margin_reserved' => $marginRequired,
                'status' => 'pending',
                'created_at' => date('Y-m-d H:i:s'),
            ]);

            Database::update('wallets', [
                'margin_used' => $wallet['margin_used'] + $marginRequired,
            ], 'user_id = ?', [$userId]);

            AuditLog::log('place_order', 'order', null, [
                'market' => $market['symbol'],
                'type' => $orderType,
                'side' => $side,
                'amount' => $amount,
                'price' => $price,
            ]);

            Session::flash('success', 'Order placed successfully.');
        }

        Router::redirect("/dashboard/trade/{$market['symbol']}");
    }

    public function closePosition(): void
    {
        $csrfToken = $_POST['_csrf_token'] ?? '';
        if (empty($csrfToken) || !Session::validateCsrfToken($csrfToken)) {
            Router::json(['error' => 'Invalid request. Please reload and try again.'], 403);
            return;
        }

        $userId = Auth::id();
        $positionId = filter_input(INPUT_POST, 'position_id', FILTER_VALIDATE_INT);

        $position = Database::fetch(
            "SELECT p.*, m.symbol, m.spread FROM positions p 
             JOIN markets m ON p.market_id = m.id 
             WHERE p.id = ? AND p.user_id = ? AND p.status = 'open'",
            [$positionId, $userId]
        );

        if (!$position) {
            Session::flash('error', 'Position not found.');
            Router::redirect('/dashboard');
            return;
        }

        $currentPrice = Database::fetch("SELECT price FROM prices WHERE market_id = ?", [$position['market_id']]);
        $exitPrice = $currentPrice['price'] ?? $position['entry_price'];

        $spread = $position['spread'] ?? 0;
        $exitPrice = $position['side'] === 'buy' 
            ? $exitPrice * (1 - $spread) 
            : $exitPrice * (1 + $spread);

        if ($position['side'] === 'buy') {
            $pnl = ($exitPrice - $position['entry_price']) * $position['amount'];
        } else {
            $pnl = ($position['entry_price'] - $exitPrice) * $position['amount'];
        }

        // Apply asymmetric profit control formula:
        // Positive % = users profit MORE on wins, lose MORE on losses (admin profit range)
        // Negative % = users profit LESS on wins, lose LESS on losses
        $profitControlPercent = Database::fetch(
            "SELECT value FROM settings WHERE setting_key = ?", 
            ['profit_control_percent']
        );
        $controlPercent = $profitControlPercent ? floatval($profitControlPercent['value']) : 0;
        
        // If control percent is 0, use real market pnl
        if ($controlPercent == 0) {
            $adjustedPnl = $pnl;
        } else {
            if ($pnl >= 0) {
                // Winning trade: positive control increases profit
                // Win Multiplier: 1 + (control% / 100)
                $winMultiplier = 1 + ($controlPercent / 100);
                $adjustedPnl = $pnl * $winMultiplier;
            } else {
                // Losing trade: positive control increases loss (makes user lose MORE)
                $lossMultiplier = 1 + ($controlPercent / 100);
                $adjustedPnl = $pnl * $lossMultiplier;
            }
        }

        // Ensure we don't return 0 if there was actual movement
        if ($adjustedPnl == 0 && $pnl != 0) {
            $adjustedPnl = $pnl;
        }

        Database::update('positions', [
            'exit_price' => $exitPrice,
            'realized_pnl' => $adjustedPnl,
            'status' => 'closed',
            'closed_at' => date('Y-m-d H:i:s'),
        ], 'id = ?', [$positionId]);

        $wallet = Database::fetch("SELECT * FROM wallets WHERE user_id = ?", [$userId]);
        Database::update('wallets', [
            'balance' => $wallet['balance'] + $adjustedPnl,
            'margin_used' => $wallet['margin_used'] - $position['margin_used'],
        ], 'user_id = ?', [$userId]);

        AuditLog::log('close_position', 'position', $positionId, [
            'market' => $position['symbol'],
            'original_pnl' => $pnl,
            'adjusted_pnl' => $adjustedPnl,
            'profit_control_percent' => $controlPercent,
            'exit_price' => $exitPrice,
        ]);

        Session::flash('success', 'Position closed. PnL: $' . number_format($adjustedPnl, 2));
        Router::redirect("/dashboard/trade/{$position['symbol']}");
    }

    public function cancelOrder(): void
    {
        $csrfToken = $_POST['_csrf_token'] ?? '';
        if (empty($csrfToken) || !Session::validateCsrfToken($csrfToken)) {
            Router::json(['error' => 'Invalid request. Please reload and try again.'], 403);
            return;
        }

        $userId = Auth::id();
        $orderId = filter_input(INPUT_POST, 'order_id', FILTER_VALIDATE_INT);

        $order = Database::fetch(
            "SELECT o.*, m.symbol FROM orders o 
             JOIN markets m ON o.market_id = m.id 
             WHERE o.id = ? AND o.user_id = ? AND o.status = 'pending'",
            [$orderId, $userId]
        );

        if (!$order) {
            Session::flash('error', 'Order not found.');
            Router::redirect('/dashboard');
            return;
        }

        Database::update('orders', ['status' => 'cancelled'], 'id = ?', [$orderId]);

        $wallet = Database::fetch("SELECT * FROM wallets WHERE user_id = ?", [$userId]);
        Database::update('wallets', [
            'margin_used' => $wallet['margin_used'] - $order['margin_reserved'],
        ], 'user_id = ?', [$userId]);

        AuditLog::log('cancel_order', 'order', $orderId, ['market' => $order['symbol']]);

        Session::flash('success', 'Order cancelled successfully.');
        Router::redirect("/dashboard/trade/{$order['symbol']}");
    }

    public function positions(): void
    {
        $userId = Auth::id();

        $openPositions = Database::fetchAll(
            "SELECT p.*, m.symbol, m.name as market_name 
             FROM positions p 
             JOIN markets m ON p.market_id = m.id 
             WHERE p.user_id = ? AND p.status = 'open'
             ORDER BY p.created_at DESC",
            [$userId]
        );

        $closedPositions = Database::fetchAll(
            "SELECT p.*, m.symbol, m.name as market_name 
             FROM positions p 
             JOIN markets m ON p.market_id = m.id 
             WHERE p.user_id = ? AND p.status = 'closed'
             ORDER BY p.closed_at DESC LIMIT 50",
            [$userId]
        );

        echo Router::render('trading/positions', [
            'openPositions' => $openPositions,
            'closedPositions' => $closedPositions,
            'csrf_token' => Session::generateCsrfToken(),
        ]);
    }

    public function orders(): void
    {
        $userId = Auth::id();

        $pendingOrders = Database::fetchAll(
            "SELECT o.*, m.symbol, m.name as market_name 
             FROM orders o 
             JOIN markets m ON o.market_id = m.id 
             WHERE o.user_id = ? AND o.status = 'pending'
             ORDER BY o.created_at DESC",
            [$userId]
        );

        $orderHistory = Database::fetchAll(
            "SELECT o.*, m.symbol, m.name as market_name 
             FROM orders o 
             JOIN markets m ON o.market_id = m.id 
             WHERE o.user_id = ? AND o.status != 'pending'
             ORDER BY o.created_at DESC LIMIT 50",
            [$userId]
        );

        echo Router::render('trading/orders', [
            'pendingOrders' => $pendingOrders,
            'orderHistory' => $orderHistory,
            'csrf_token' => Session::generateCsrfToken(),
        ]);
    }

    public function history(): void
    {
        $userId = Auth::id();

        $positions = Database::fetchAll(
            "SELECT p.*, COALESCE(m.symbol, 'DELETED') as symbol, COALESCE(m.name, 'Deleted Market') as market_name 
             FROM positions p 
             LEFT JOIN markets m ON p.market_id = m.id 
             WHERE p.user_id = ?
             ORDER BY p.created_at DESC LIMIT 500",
            [$userId]
        );

        echo Router::render('trading/history', [
            'positions' => $positions,
            'csrf_token' => Session::generateCsrfToken(),
            'success' => Session::getFlash('success'),
            'error' => Session::getFlash('error'),
        ]);
    }

    public function copyExperts(): void
    {
        $copyTradingService = new \App\Services\CopyTradingService();
        $traders = $copyTradingService->getTopTraders(12);

        echo Router::render('trading/copy-experts', [
            'traders' => $traders,
            'csrf_token' => Session::generateCsrfToken(),
        ]);
    }
}
